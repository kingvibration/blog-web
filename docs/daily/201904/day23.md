<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
  <pre>

    [html] 关于form标签的enctype属性你有哪些了解？

      form 标签的 enctype 属性，用来控制表单上传的数据的编码格式。其值和 HTTP 请求的 Content-type 值一样。在数据提交到服务器之前，会以 enctype 的值进行编码。

      enctype 对应的值如下

      值                               	  用法
      application/x-www-form-urlencoded	  默认值，会对所有字符转进行编码 （将空格转换为 "+" 符号，特殊字符转换为 ASCII HEX 值）
      multipart/form-data	                不会对字符进行编码，当表单中有文件时必须要此编码
      text/plain	                        将空格转换为 "+" 符号，但不编码特殊字符


    [css] 说说CSS的优先级是如何计算的？

      !important > 内联样式（1000） > id 选择器（100） > class 选择器（10） > tag（1） > *

      ◆不要在ID选择器前使用标签名

      ◆不要再class选择器前使用标签名

      ◆尽量少使用层级关系

      ◆使用class代替层级关系

    [js] 0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？<a href="https://github.com/haizlin/fe-interview/issues/80">详情</a>

      之所以会出现0.1 + 0.2 != 0.3这种问题，原因在于我们现实世界中使用十进制来表示数字，但是计算机中只能使用二进制来表示数字，小数也是用二进制来表示。
      JavaScript存储二进制数据也是有限度的，正如在现实中我们无法写下一个无限循环的小数一样，只能写个近似数。

      用一句话概括就是：

      EcmaScrpt规范定义Number的类型遵循了IEEE754-2008中的64位浮点数规则定义的小数后的有效位数至多为52位导致计算出现精度丢失问题！

      这个问题也算是经常遇到的面试题之一了，楼上说的对，简单来说就是js中采用IEEE754的双精度标准，因为精度不足导致的问题，比如二进制表示0.1时这这样表示1001100110011...(0011无线循环)，那么这些循环的数字被js裁剪后，就会出现精度丢失的问题，也就造成了0.1不再是 0.1 了，而是变成了 0.100000000000000002
      我们可以来测试一下：

      0.100000000000000002 === 0.1//true
      那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002:

      0.200000000000000002 === 0.2 // true
      由此我们可以得出:

      0.1 + 0.2 === 0.30000000000000004//true
      所以自然0.1+0.2!=0.3。
      那么如何解决这个问题；使用原生最简单的方法:


      parseFloat((0.1+0.2).toFixed(10)) === 0.3//true



      <a href="https://www.jianshu.com/p/d6b81e4e25e3">深度剖析0.1 +0.2===0.30000000000000004的原因</a>



    [软技能] 说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事

      我觉暂时除了有胜任工作的业务能力，hr会觉得加分的项是自觉996、自觉加班、家住的近（方便加班）、廉价（工资低）和业务能力超强（相当于全栈，可以减少公司成本，基于小公司）


  </pre>
</body>

<script>

  //手写

  //实现

</script>
</html>
