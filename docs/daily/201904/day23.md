
## [html] 关于form标签的enctype属性你有哪些了解？

  form 标签的 enctype 属性，用来控制表单上传的数据的编码格式。其值和 HTTP 请求的 Content-type 值一样。在数据提交到服务器之前，会以 enctype 的值进行编码。

  enctype 对应的值如下

  |值 |                              	  用法|
  |:-|:-|
  |application/x-www-form-urlencoded|	  默认值，会对所有字符转进行编码 （将空格转换为 "+" 符号，特殊字符转换为 ASCII HEX 值）|
  |multipart/form-data|	               不会对字符进行编码，当表单中有文件时必须要此编码|
  |text/plain|	                        将空格转换为 "+" 符号，但不编码特殊字符|


## [css] 说说CSS的优先级是如何计算的？

  !important > 内联样式（1000） > id 选择器（100） > class 选择器（10） > tag（1） > *

  ◆不要在ID选择器前使用标签名

  ◆不要再class选择器前使用标签名

  ◆尽量少使用层级关系

  ◆使用class代替层级关系

## [js] 0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？<a href="https://github.com/haizlin/fe-interview/issues/80">详情</a>

  之所以会出现0.1 + 0.2 != 0.3这种问题，原因在于我们现实世界中使用十进制来表示数字，但是计算机中只能使用二进制来表示数字，小数也是用二进制来表示。
  JavaScript存储二进制数据也是有限度的，正如在现实中我们无法写下一个无限循环的小数一样，只能写个近似数。

  用一句话概括就是：

  EcmaScrpt规范定义Number的类型遵循了IEEE754-2008中的64位浮点数规则定义的小数后的有效位数至多为52位导致计算出现精度丢失问题！

  这个问题也算是经常遇到的面试题之一了，楼上说的对，简单来说就是js中采用IEEE754的双精度标准，因为精度不足导致的问题，比如二进制表示0.1时这这样表示1001100110011...(0011无线循环)，那么这些循环的数字被js裁剪后，就会出现精度丢失的问题，也就造成了0.1不再是 0.1 了，而是变成了 0.100000000000000002
  我们可以来测试一下：

  0.100000000000000002 === 0.1//true
  那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002:

  0.200000000000000002 === 0.2 // true
  由此我们可以得出:

  0.1 + 0.2 === 0.30000000000000004//true
  所以自然0.1+0.2!=0.3。
  那么如何解决这个问题；使用原生最简单的方法:


  parseFloat((0.1+0.2).toFixed(10)) === 0.3//true



  <a href="https://www.jianshu.com/p/d6b81e4e25e3">深度剖析0.1 +0.2===0.30000000000000004的原因</a>



## [软技能] 说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事

  我觉暂时除了有胜任工作的业务能力，hr会觉得加分的项是自觉996、自觉加班、家住的近（方便加班）、廉价（工资低）和业务能力超强（相当于全栈，可以减少公司成本，基于小公司）

